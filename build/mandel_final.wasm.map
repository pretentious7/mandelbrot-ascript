{"version":3,"sources":["~lib/rt/common.ts","assembly/mandel_final.ts"],"names":[],"mappings":"","sourceRoot":"./mandel_final.wasm","sourcesContent":["// Alignment guarantees\n\n// @ts-ignore: decorator\n@inline export const AL_BITS: u32 = 4; // 16 bytes to fit up to v128\n// @ts-ignore: decorator\n@inline export const AL_SIZE: usize = 1 << <usize>AL_BITS;\n// @ts-ignore: decorator\n@inline export const AL_MASK: usize = AL_SIZE - 1;\n\n// Extra debugging\n\n// @ts-ignore: decorator\n@inline export const DEBUG = true;\n// @ts-ignore: decorator\n@inline export const TRACE = false;\n// @ts-ignore: decorator\n@inline export const RTRACE = isDefined(ASC_RTRACE);\n// @ts-ignore: decorator\n@inline export const PROFILE = isDefined(ASC_PROFILE);\n\n// Memory manager\n\n// ╒════════════ Memory manager block layout (32-bit) ═════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                           MM info                             │ -4\n// ╞>ptr═══════════════════════════════════════════════════════════╡\n// │                              ...                              │\n@unmanaged export class BLOCK {\n  /** Memory manager info. */\n  mmInfo: usize;\n}\n\n/** Overhead of a memory manager block. */\n// @ts-ignore: decorator\n@inline export const BLOCK_OVERHEAD: usize = offsetof<BLOCK>();\n\n/** Maximum size of a memory manager block's payload. */\n// @ts-ignore: decorator\n@inline export const BLOCK_MAXSIZE: usize = (1 << 30) - BLOCK_OVERHEAD;\n\n// Garbage collector\n\n// ╒══════════ Garbage collector object layout (32-bit) ═══════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                     Memory manager block                      │ -20\n// ╞═══════════════════════════════════════════════════════════════╡\n// │                            GC info                            │ -16\n// ├───────────────────────────────────────────────────────────────┤\n// │                            GC info                            │ -12\n// ├───────────────────────────────────────────────────────────────┤\n// │                            RT id                              │ -8\n// ├───────────────────────────────────────────────────────────────┤\n// │                            RT size                            │ -4\n// ╞>ptr═══════════════════════════════════════════════════════════╡\n// │                              ...                              │\n@unmanaged export class OBJECT extends BLOCK {\n  /** Garbage collector info. */\n  gcInfo: u32;\n  /** Garbage collector info. */\n  gcInfo2: u32;\n  /** Runtime class id. */\n  rtId: u32;\n  /** Runtime object size. */\n  rtSize: u32;\n}\n\n/** Overhead of a garbage collector object. Excludes memory manager block overhead. */\n// @ts-ignore: decorator\n@inline export const OBJECT_OVERHEAD: usize = (offsetof<OBJECT>() - BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK;\n\n/** Maximum size of a garbage collector object's payload. */\n// @ts-ignore: decorator\n@inline export const OBJECT_MAXSIZE: usize = BLOCK_MAXSIZE - OBJECT_OVERHEAD;\n\n/** Total of memory manager and garbage collector overhead. */\n// @ts-ignore: decorator\n@inline export const TOTAL_OVERHEAD: usize = BLOCK_OVERHEAD + OBJECT_OVERHEAD;\n","\ndeclare const canvas_width: i32;\ndeclare const canvas_height: i32;\ndeclare const ITER_CONST: i32;\ndeclare const DIV_CLASS: u8;\ndeclare const N_THREADS: u8;\ndeclare const START_X_TOTAL:f32\ndeclare const START_Y_TOTAL:f32\ndeclare const WINDOW:f32\n\n\n//const ITER_CONST:i32 = 1000;\n\n@inline\nfunction mandelbrot(c_r:f64, c_i:f64):i8{\n  let in_set: i8 = 0;\n  let z_r:f64 = 0., z_i:f64 = 0., t_r:f64 = 0., t_i:f64 = 0.;\n  for(let count = 0; z_r*z_r + z_i*z_i < 4; count++) {\n    t_r = z_r*z_r - z_i*z_i + c_r;\n    t_i = 2*z_i*z_r + c_i;\n    z_r = t_r;\n    z_i = t_i;\n    if(count > ITER_CONST) {\n      in_set = 1;\n      break;\n    }\n  }\n  return in_set;\n}\n\n@inline\nfunction mandelbrot_simd(c_rl:v128,c_il:v128):v128{\n    let in_set : v128 = i32x4(0,0,0,0);\n    let z_r : v128 = f32x4(0.,0.,0.,0.);\n    let z_i : v128 = f32x4(0.,0.,0.,0.);\n    let t_r : v128 = f32x4(0.,0.,0.,0.);\n    let t_i : v128 = f32x4(0.,0.,0.,0.);\n    //const zeros = i32x4(0,0,0,0)\n    const ones = i32x4(1,1,1,1)\n    const fours = f32x4(4.,4.,4.,4.)\n    //const twos = f32x4(2.,2.,2.,2.)\n    //const ITER_CONSTS:v128 = i32x4(ITER_CONST,ITER_CONST,ITER_CONST,ITER_CONST)\n    const ITER_CONSTS:v128 = v128.splat<i32>(ITER_CONST);\n    /*for(let count=i32x4(0,0,0,0);\n    v128.all_true(v128.le<f32>(v128.mul<f32>(z_r,z_r) + v128.mul<f32>(z_i,z_i),fours));\n    count = v128.add<i32>(count,ones)){*/\n    let count:v128=i32x4(0,0,0,0)\n    for(\n        let total_count:i32 = 0, any_in_convergence_region:boolean = true;\n        any_in_convergence_region &&\n        total_count < ITER_CONST;\n        total_count++\n    ) {\n        z_i = v128.add<f32>(c_il, v128.mul<f32>(v128.add<f32>(z_r,z_r),z_i))\n        z_r = v128.add<f32>(c_rl, v128.sub<f32>(t_r,t_i))\n        t_r = v128.mul<f32>(z_r,z_r)\n        t_i = v128.mul<f32>(z_i,z_i)\n        const mask = v128.le<f32>(v128.add<f32>(t_r,t_i),fours)\n        any_in_convergence_region = v128.any_true(mask)\n        count = v128.add<i32>(count, v128.and(ones,mask))\n    }\n    /* {\n        t_r = v128.add<f32>(v128.sub<f32>(v128.mul<f32>(z_r,z_r),v128.mul<f32>(z_i,z_i)),c_rl);\n        z_i = v128.add<f32>(v128.mul<f32>(v128.mul<f32>(z_i,z_r), twos),c_il);\n        z_r = t_r;\n        //z_i = t_i;\n        const mask = v128.le<f32>(v128.add<f32>(v128.mul<f32>(z_r,z_r),v128.mul<f32>(z_i,z_i)),fours)\n        any_in_convergence_region = v128.any_true(mask)\n        count = v128.add<i32>(count, v128.and(ones,mask))\n    }*/\n    return count;\n}\n\n    /*\n    while(\n    v128.all_true<i32>(v128.le<f32>(v128.add<f32>(v128.mul<f32>(z_r,z_r),v128.mul<f32>(z_i,z_i)),fours)) &&\n    v128.all_true<i32>(v128.gt<i32>(ITER_CONSTS,count))\n    ){\n        t_r = v128.add<f32>(v128.sub<f32>(v128.mul<f32>(z_r,z_r),v128.mul<f32>(z_i,z_i)),c_rl);\n        t_i = v128.add<f32>(v128.mul<f32>(v128.mul<f32>(z_i,z_r), f32x4(2.,2.,2.,2.)),c_il);\n        z_r = t_r;\n        z_i = t_i;\n        const mask = v128.le<f32>(v128.add<f32>(v128.mul<f32>(z_r,z_r),v128.mul<f32>(z_i,z_i)),fours)\n        count = v128.add<i32>(count,mask)\n    }\n    */\n/*\n    return i32x4(1,1,1,1);\n}\n*/\n\n\n//mandelbrot_simd(f32x4(0.1,0.3,0.2,0.1),f32x4(0.1,0.3,0.2,0.1))\n//(-0.761574,-0.0847596\n//-1.62917,-0.0203968\n/*\nconst START_X_TOTAL:f32 = -2.0\nconst START_Y_TOTAL:f32 =  -2.0\nconst WINDOW:f32 = 4.\n*/\nconst step_X:f32= WINDOW/f32(canvas_width);\nconst step_Y:f32 = WINDOW/f32(canvas_height);\nconst segment:i32 = canvas_height/N_THREADS;\nconst start_yc:i32 = DIV_CLASS * (segment);\nconst start_y = START_Y_TOTAL + f32(start_yc) * step_Y;\nconst start_x:f32 = START_X_TOTAL;\nconst end_yc:i32 = start_yc + segment;\nlet a1 = f32x4(0,0,0,0);\nlet a2 = f32x4(0,0,0,0);\nlet memcounter = start_yc * canvas_width * 4;\n\n//for (let x = -2.0, count_x = 0; count_x < canvas_width; x += step_X, count_x++){\nfor (let y:f32 = start_y, count_y =start_yc; count_y < end_yc; y += step_Y, count_y ++) {\n    a1 = v128.splat<f32>(y);\n    for(let x:f32 = start_x, count_x = 0; count_x < canvas_width; x+=4*step_X, count_x+=4){ \n        a2 = v128.replace_lane<f32>(v128.replace_lane<f32>(v128.replace_lane<f32>(v128.replace_lane<f32>(a2,3,x+3*step_X),2,x+2*step_X),1,x+step_X),0,x);\n        v128.store((memcounter), mandelbrot_simd(a2,a1))\n        memcounter+=16\n    }\n}\n\n\n/*for ( let x:f32 = start_x, count_x = start_xc; count_x < end_xc; x += step_X, count_x++){\n    a1 = v128.splat<f32>(x);\n  for (let y:f32 = start_y, count_y = 0; count_y < canvas_height; y += 4*step_Y, count_y+=4){\n      */\n    //store<boolean>(count_x*canvas_height + count_y, mandelbrot(x,y));\n    \n    /*\n    a2 = v128.replace_lane<f32>(a2,0,y);\n    a2 = v128.replace_lane<f32>(a2,1,y+step_Y);\n    a2 = v128.replace_lane<f32>(a2,2,y+2*step_Y);\n    a2 = v128.replace_lane<f32>(a2,3,y+3*step_Y);\n    */\n    \n    \n    //a2 = v128.replace_lane<f32>(v128.replace_lane<f32>(v128.replace_lane<f32>(v128.replace_lane<f32>(a2,3,y+3*step_Y),2,y+2*step_Y),1,y+step_Y),0,y);\n\n    //v128.store\n    //v128.store(4*(count_x*canvas_height + count_y), mandelbrot_simd(a1,a2))\n    //v128.store((memcounter+=16), mandelbrot_simd(a1,a2))\n    //memcounter+=16\n\n    //v128.store(count_x*canvas_height + count_y, a2)\n\n  //}\n\n//}\n\n\n//v128.store(0,v128.ge<i8>(v128.splat<i8>(121),v128.splat<i8>(120)))\n\n"]}